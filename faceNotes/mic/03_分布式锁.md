## 分布式锁

### 分布式锁的理解和实现

资料来源：[分布式锁的理解和实现](https://www.toutiao.com/video/7081573477920014878/?from_scene=all)

分布式锁， 是一种跨进程的跨机器节点的互斥锁， 它可以用来保证多机器节点对于共享资源访问的排他性<br/>

![image-20221008143503512](img/image-20221008143503512.png ':size=40%')

我觉得分布式锁和线程锁本质上是一样的，线程锁的生命周期是单进程多线程，分布式锁的声明周期是多进程多机器节点。<br/>
在本质上，他们都需要满足锁的几个重要特性：<br/>

-  排他性，也就是说，同一时刻只能有一个节点去访问共享资源。<br/>
-  可重入性，允许一个已经获得锁的进程，在没有释放锁之前再次重新获得锁。<br/>
-  锁的获取、释放的方法<br/>
-  锁的失效机制，避免死锁的问题<br/>
-  
所以，我认为，只要能够满足这些特性的技术组件都能够实现分布式锁。<br/>

- 1. 关系型数据库，可以使用唯一约束来实现锁的排他性，<br/>
如果要针对某个方法加锁，就可以创建一个表包含方法名称字段，并且把方法名设置成唯一的约束。<br/>
那抢占锁的逻辑就是：往表里面插入一条数据，如果已经有其他的线程获得了某个方法的锁，那这个时候插入数据会失败，从而保证了互斥性。<br/>
这种方式虽然简单啊，但是要实现比较完整的分布式锁，还需要考虑重入性、锁失效机制、没抢占到锁的线程要实现阻塞等，就会比较麻烦。<br/>
- 2. Redis，它里面提供了 SETNX 命令可以实现锁的排他性，当 key 不存在就返回 1，存在就返回 0。然后还可以用 expire 命令设置锁的失效时间，从而避免死锁问题。<br/>
当然有可能存在锁过期了，但是业务逻辑还没执行完的情况。 所以这种情况，可以写一个定时任务对指定的 key 进行续期。
Redisson 这个开源组件，就提供了分布式锁的封装实现，并且也内置了一个 Watch Dog 机制来对 key 做续期。<br/>
我认为 Redis 里面这种分布式锁设计已经能够解决 99%的问题了，当然如果在 Redis搭建了高可用集群的情况下出现主从切换导致 key 失效，这个问题也有可能造成多个线程抢占到同一个锁资源的情况，所以 Redis 官方也提供了一个 RedLock 的解决办法，但是实现会相对复杂一些。<br/>
- 3. 在我看来，分布式锁应该是一个 CP 模型，而 Redis 是一个 AP 模型，所以在集群架构下由于数据的一致性问题导致极端情况下出现多个线程抢占到锁的情况很难避免。<br/>
那么基于 CP 模型又能实现分布式锁特性的组件，我认为可以选择 Zookeeper 或者etcd，<br/>
>  1,在**数据一致性方面**，zookeeper 用到了 zab 协议来保证数据的一致性，etcd用到了 raft 算法来保证数据一致性。<br/>
> 2,在**锁的互斥方面**，zookeeper 可以基于有序节点再结合 Watch 机制实现互斥和唤醒，etcd 可以基于 Prefix 机制和 Watch 实现互斥和唤醒。<br/>

以上就是我对于分布式锁的理解！<br/>

#### 面试点评

我认为，回答这个问题的核心本质，还是在技术底层深度理解的基础上的思考。<br/>
可以从高手的回答中明显感受到，对于排它锁底层逻辑的理解是很深刻的，同时再技术的广度上也是有足够的积累。<br/>
所以在回答的时候，面试官可以去抓到求职者在回答这个问题的时候的技术关键点和技术思维。  

### 实现分布式锁的解决方案中，你认为Zookeeper和Redis哪种更好？

资料来源：[实现分布式锁的解决方案中，你认为Zookeeper和Redis哪种更好？](https://www.toutiao.com/video/7032604058363888135/)

#### 普通人：
Redis 可以使用 SetNX 这个指令来实现分布式锁，Zookeeper 可以基于同一级节点的
唯一性或者有序节点的特性来实现分布式锁。由于 Redis 的读写性能要比 Zookeeper
更好，在高并发场景中，Zookeeper 实现分布式锁会存在性能瓶颈。所以我认为 Redis
比 Zookeeper 更好。
#### 高手：
关于这个问题，我想从 3 个方面来说：
**1. 为什么使用分布式锁？**
使用分布式锁的目的，是为了保证同一时间只有一个 JVM 进程可以对共享资源进行操
作。
根据锁的用途可以细分为以下两类：

- 允许多个客户端操作共享资源，我们称为共享锁
  这种锁的一般是对共享资源具有幂等性操作的场景，主要是为了避免重复操作共享资源
  频繁加锁带来的性能开销。

- 只允许一个客户端操作共享资源，我们成为排他锁
  这种锁一般是用在对共享资源操作具有非幂等性操作的场景，也就是需要保证在同一时
  刻只有一个进程或者线程能够访问这个共享资源。

**2. 目前实现分布式锁最常用的中间件是 Redis 和 Zookeeper**
 **a. 第一种，Redis 可以通过两种方式来实现  **

i. 利用 Redis 提供的`SET key value NX PX milliseconds `指令，这个指令是设置一个 key-value，如果 key 已经存在，则返回 0，否则返回 1，我们基于这个返回值来判断锁的占用情况从而实现分布式锁。

ii. 基于 Redission 客户端来实现分布式锁，Redisson 提供了分布式锁的封装方法，我们只需要调用 api 中的`lock（）`和`unlock()`方法。它帮我们封装锁实现的细节和复杂度

> 1. redisson 所有指令都通过 lua 脚本执行并支持 lua 脚本原子性执行
>
> 2. redisson 中有一个 watchdog 的概念，翻译过来就是看门狗，它会在
>    你获取锁之后，每隔 10 秒帮你把 key 的超时时间设为 30s，就算一
>    直持有锁也不会出现 key 过期了。“看门狗”的逻辑保证了没有死锁
>    发生  

**b. 第二种，基于 ZK 实现分布式锁的落地方案**
Zookeeper 实现分布式锁的方法比较多，我们可以使用有序节点来实现，
i. 每个线程或进程在 Zookeeper 上的`/lock`目录下创建一个临时有序的节
点表示去抢占锁，所有创建的节点会按照先后顺序生成一个带有序编号的
节点。
ii. 线程创建节点后，获取/lock 节点下的所有子节点，判断当前线程创建的
节点是否是所有的节点的序号最小的。
iii. 如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。
iv. 如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听，当前一个被监听的节点释放锁之后，触发回调通知，从而再次去尝试抢占锁。

**3. 两种方案都有各自的优缺点**

对于 redis 的分布式锁而言，它有以下缺点：

- 它获取锁的方式简单粗暴，如果获取不到锁，会不断尝试获取锁，比较消耗性能。
- Redis 是 AP 模型，在集群模式中由于数据的一致性会导致锁出现问题，即便使用
  Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100%的可靠性。
  不过在实际开发中使用 Redis 实现分布式锁还是比较常见，而且大部分场情况下不会遇
  到”极端复杂的场景“，更重要的是 Redis 性能很高，在高并发场景中比较合适。  

对于 zk 分布式锁而言:
- zookeeper 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。
- 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。如果要在两者之间做选择，就我个人而言的话，比较推崇 ZK 实现的锁，因为对于分布式锁而言，它应该符合 CP 模型，但是 Redis 是 AP 模型，所以在这个点上，Zookeeper会更加合适。  