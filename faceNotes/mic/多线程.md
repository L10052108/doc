## 线程

### 谈谈你对线程安全的理解

资料来源：[谈谈你对线程安全的理解](https://www.toutiao.com/video/7085655943110722062/?from_scene=all)

Hi， 大家好， 我是 Mic
一个工作了 4 年的小伙伴， 遇到了一个非常抽象的面试题， 说说你对线程安全性
的理解。
这类问题， 对于临时刷面试题来面试的小伙伴， 往往是致命的。
一个是不知道从何说起， 也就是语言组织比较困难。
其次就是， 如果对于线程安全性没有一定程度的理解， 一般很难说出你的理解。
ok， 我们来看看这个问题的回答。  

#### 高手

简单来说， 在多个线程访问某个方法或者对象的时候， 不管通过任何的方式调用以及线程如何去交替执行。
在程序中不做任何同步干预操作的情况下， 这个方法或者对象的执行/修改都能按照预期的结果来反馈， 那么这个类就是线程安全的。
实际上， 线程安全问题的具体表现体现在三个方面， 原子性、 有序性、 可见性。
原子性呢， 是指当一个线程执行一系列程序指令操作的时候， 它应该是不可中断的， 因为一旦出现中断， 站在多线程的视角来看， 这一系列的程序指令会出现前后执行结果不一致的问题。
这个和数据库里面的原子性是一样的， 简单来说就是一段程序只能由一个线程完整的执行完成， 而不能存在多个线程干扰。
CPU 的 上 下 文 切 换 ， 是 导 致 原 子 性 问 题 的 核 心 ， 而 JVM 里 面 提 供 了Synchronized 关键字来解决原子性问题  

![image-20231225153939801](img/image-20231225153939801.png)

可见性， 就是说在多线程环境下， 由于读和写是发生在不同的线程里面， 有可能出现某个线程对共享变量的修改， 对其他线程不是实时可见的。
导致可见性问题的原因有很多， 比如 CPU 的高速缓存、 CPU 的指令重排序、 编译器的指令重排序。
有序性， 指的是程序编写的指令顺序和最终 CPU 运行的指令顺序可能出现不一致的现象， 这种现象也可以称为指令重排序， 所以有序性也会导致可见性问题。
可见性和有序性可以通过 JVM 里面提供了一个 Volatile 关键字来解决。
在我看来， 导致有序性、 原子性、 可见性问题的本质， 是计算机工程师为了最大化提升 CPU 利用率导致的。 比如为了提升 CPU 利用率， 设计了三级缓存、 设计了 StoreBuffer、 设计了缓存行这种预读机制、 在操作系统里面， 设计了线程模型、 在编译器里面， 设计了编译器的深度优化机制。
一上就是我对这个问题的理解。  

#### 面试点评

从高手的回答中， 可以很深刻的感受到， 他对于计算机底层原理和线程安全性相
关的底层实现是理解得很透彻的。

对我来说， 这个人去写程序代码， 不用担心他滥用线程导致一些不可预测的线程安全性问题了， 这就是这个面试题的价值。
好的， 本期的普通人 VS 高手面试系列的视频就到这里结束了， 喜欢的朋友记得点赞和收藏。
另外， 这些面试题我都整理成了笔记， 大家有需要的可以私信获取。
我是 Mic， 一个工作了 14 年的 Java 程序员， 咱们下期再见  

### 什么是守护线程，它有什么特点？

资料来源：[什么是守护线程，它有什么特点？](https://www.toutiao.com/video/7101505375253299748/?from_scene=all)

守护线程， 它是一种专门为用户线程提供服务的线程， 它的生命周期依赖于用户线程。<br/>
只有 JVM 中仍然还存在用户线程正在运行的情况下， 守护线程才会有存在的意义。<br/>
否则， 一旦 JVM 进程结束， 那守护线程也会随之结束。<br/>
也就是说， 守护线程不会阻止 JVM 的退出。 但是用户线程会！<br/>
守护线程和用户线程的创建方式是完全相同的， 我们只需要调用用户线程里面的setDaemon 方法并且设置成 true， 就表示这个线程是守护线程。<br/>
因为守护线程拥有自己结束自己生命的特性， 所以它适合用在一些后台的通用服务场景里面。<br/>
比如 JVM 里面的垃圾回收线程， 就是典型的使用场景。<br/>
这个场景的特殊之处在于， 当 JVM 进程技术的时候， 内存回收线程存在的意义也就不存在了。<br/>
所以不能因为正在进行垃圾回收导致 JVM 进程无法技术的问题。<br/>
但是守护线程不能用在线程池或者一些 IO 任务的场景里面， 因为一旦 JVM 退出之后， 守护线程也会直接退出。<br/>
就会可能导致任务没有执行完或者资源没有正确释放的问题。



### 如果一个线程两次调用start()，会出现什么问题？

资料来源：[如果一个线程两次调用start()，会出现什么问题？](https://www.toutiao.com/video/7101505375253299748/?from_scene=all)

在 Java 里面， 一个线程只能调用一次 start() 方法， 第二次调用会抛出IllegalThreadStateException。
一个线程本身是具备一个生命周期的。
在 Java 里面， 线程的生命周期包括 6 种状态。
**NEW**， 线程被创建还没有调用 start 启动<br/>
**RUNNABLE**， 在这个状态下的线程有可能是正在运行， 也可能是在就绪队列里
面等待操作系统进行调度分配 CPU 资源。<br/>
**BLOCKED**， 线程处于锁等待状态。<br/>
**WAITING**， 表示线程处于条件等待状态， 当触发条件后唤醒， 比如 wait/notify。<br/>
**TIMED_WAIT**， 和 WAITING 状态相同， 只是它多了一个超时条件触发。<br/>
**TERMINATED**， 表示线程执行结束。<br/>
当我们第一次调用 start()方法的时候， 线程的状态可能处于终止或者非 NEW 状态下的其他状态。<br/>
再调用一次 start()， 相当于让这个正在运行的线程重新运行， 不管从线程的安全性角度， 还是从线程本身的执行逻辑， 都是不合理的。<br/>
因此为了避免这个问题， 在线程运行的时候会先判断当前线程的运行状态。<br/>
以上就是我对这个问题的理解

### 每天CRUD，日常也不用ThreadLocal啊，为什么面试会问ThreadLocal

资料来源：[每天CRUD，日常也不用ThreadLocal啊，为什么面试会问ThreadLocal](https://www.toutiao.com/video/7084186464350634509/?from_scene=all)<br/>

好的， 这个问题我从三个方面来回答。<br/>
ThreadLocal 是一种线程隔离机制， 它提供了多线程环境下对于共享变量访问的安全性。<br/>
在多线程访问共享变量的场景中， 一般的解决办法是对共享变量加锁， 从而保证在同一时刻只有一个线程能够对共享变量进行更新， 并且基于 Happens-Before
规则里面的监视器锁规则， 又保证了数据修改后对其他线程的可见性。<br/>

![image-20221008140912886](img/image-20221008140912886.png ':size=40%')<br/>
但是加锁会带来性能的下降， 所以 ThreadLocal 用了一种空间换时间的设计思想，<br/>
也就是说在每个线程里面， 都有一个容器来存储共享变量的副本， 然后每个线程只对自己的变量副本来做更新操作， 这样既解决了线程安全问题， 又避免了多线
程竞争加锁的开销<br/>

![image-20221008140952184](img/image-20221008140952184.png ':size=40%')<br/>
ThreadLocal 的 具 体 实 现 原 理 是 ， 在 Thread 类 里 面 有 一 个 成 员 变 量ThreadLocalMap， 它专门来存储当前线程的共享变量副本， 后续这个线程对于共享变量的操作， 都是从这个 ThreadLocalMap 里面进行变更， 不会影响全局共享变量的值。<br/>
以上就是我对这个问题的理解。<br/>
<hr/>

### 谈谈你对AQS的理解

资料来源：[谈谈你对AQS的理解](https://www.toutiao.com/video/7071116552212316708/?from_scene=all)<br/>

QS 是多线程同步器， 它是 J.U.C 包中多个组件的底层实现， 如 Lock、CountDownLatch、 Semaphore 等都用到了 AQS.<br/>
从本质上来说， AQS 提供了两种锁机制， 分别是排它锁， 和共享锁。<br/>
排它锁， 就是存在多线程竞争同一共享资源时， 同一时刻只允许一个线程访问该共享资源， 也就是多个线程中只能有一个线程获得锁资源， 比如 Lock 中的
ReentrantLock 重入锁实现就是用到了 AQS 中的排它锁功能。<br/>
共享锁也称为读锁， 就是在同一时刻允许多个线程同时获得锁资源， 比如CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。<br/>

### 这么回答提升30%的面试通过率，ThreadLocal出现内存泄露吗？

文字教程 [「Java」这么回答提升30%的通过率，ThreadLocal出现内存泄露吗？](https://www.toutiao.com/article/7146028552499151393/)

视频教程 [「Java」这么回答提升30%的通过率，ThreadLocal出现内存泄露吗？](https://www.toutiao.com/video/7136849327271608840/)


ThreadLocal是一个用来解决线程安全性问题的工具。

它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。

然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。

它的工作原理很简单每个线程里面有一个成员变量ThreadLocalMap。

当线程访问用ThreadLocal修饰的共享数据的时候这个线程就会在自己成员变量ThreadLocalMap里面保存一份数据副本。

key指向ThreadLocal这个引用，并且是弱引用关系，而value保存的是共享数据的副本。

因为每个线程都持有一个副本，所以就解决了线程安全性问题。

![3](img/3.png ':size=60%')

这个问题考察的是内存泄漏，所以必然和对象引用有关系。

ThreadLocal中的引用关系如图所示，Thread中的成员变量ThreadLocalMap，它里面的可以key指向ThreadLocal这个成员变量，并且它是一个弱引用所谓弱引用，就是说成员变量ThreadLocal允许在这种引用关系存在的情况下，被GC回收。

一旦被回收，key的引用就变成了null，就会导致这个内存永远无法被访问，造成内存泄漏。

![image-20221008152302427](img/image-20221008152302427.png ':size=50%')



那到底ThreadLocal会不会存在内存泄漏呢？

从ThreadLocal本身的设计上来看，是一定存在的。

可能有些小伙伴忍不住想怼我了，如果这个线程被回收了，那线程里面的成员变量都会被回收。

就不会存在内存泄漏问题啊？

这样理解没问题，但是在实际应用中，我们一般都是使用线程池，而线程池本身是重复利用的所以还是会存在内存泄漏的问题。

除此之外啊，ThreadLocal为了避免内存泄漏问题，当我们在进行数据的读写时，ThreadLocal默认会去尝试做一些清理动作，找到并清理Entry里面key为null的数据。

但是，它仍然不能完全避免，有同学就问了，那怎么办啊！！！

有两个方法可以避免：

- 每次使用完ThreadLocal以后，主动调用remove()方法移除数据
- 把ThreadLocal声明称全局变量，使得它无法被回收

ThreadLocal本身的设计并不复杂，要想深入了解，建议大家去看看源码！



回答：

我认为，不恰当的使用ThreadLocal，会造成内存泄漏问题。

主要原因是，线程的私有变量ThreadLocalMap里面的key是一个弱引用。

弱引用的特性，就是不管是否存在直接引用关系，当成员ThreadLocal没用其他的强引用关系的时候，这个对象会被GC回收掉。

从而导致key可能变成null，造成这块内存永远无法访问，出现内存泄漏的问题。

规避内存泄漏的方法有两个：

通过扩大成员变量ThreadLoca的作用域，避免被GC回收
每次使用完ThreadLocal以后，调用remove方法移除对应的数据
第一种方法虽然不会造成key为null的现象，但是如果后续线程不再继续访问这个key。

也会导致这个内存一直占用不释放，最后造成内存溢出的问题。

所以我认为最好是在使用完以后调用remove方法移除。

<hr/>

## 线程池

### Java官方提供了哪几种线程池，分别有什么特点？

资料来源：[Java官方提供了哪几种线程池，分别有什么特点？](https://www.toutiao.com/video/7123817991153811975/?from_scene=all)

#### 介绍：

> “Java 官方提供了哪几种线程池， 分别有什么特点？ ”
> 这是一道针对工作 3 年左右的面试题， 屏幕前的小伙伴， 你能回答上来吗？  

#### 回答

JDK 中幕刃提供了 5 中不同线程池的创建方式， 下面我分别说一下每一种线程池以及它的特点。<br/>
**newCachedThreadPool**， 是一种可以缓存的线程池， 它可以用来处理大量短期的突发流量。
它的特点有三个， 最大线程数是 Integer.MaxValue， 线程存活时间是 60 秒， 阻塞队列用的是 SynchronousQueue， 这是一种不存才任何元素的阻塞队列， 也就是每提交一个任务给到线程池， 都会分配一个工作线程来处理， 由于最大线程数没有限制。所以它可以处理大量的任务， 另外每个工作线程又可以存活 60s， 使得这些工作线程可以缓存起来应对更多任务的处理。

**newFixedThreadPool**， 是一种固定线程数量的线程池。它的特点是核心线程和最大线程数量都是一个固定的值如果任务比较多工作线程处理不过来， 就会加入到阻塞队列里面等待。

**newSingleThreadExecutor**， 只有一个工作线程的线程池。并且线程数量无法动态更改， 因此可以保证所有的任务都按照 FIFO 的方式顺序执行。

**newScheduledThreadPool**， 具有延迟执行功能的线程池可以用它来实现定时调度

**newWorkStealingPool**， Java8 里面新加入的一个线程池它内部会构建一个 ForkJoinPool， 利用工作窃取的算法并行处理请求。
这些线程都是通过工具类 Executors 来构建的， 线程池的最终实现类是ThreadPoolExecutor。  

### 简述一下你对线程池的理解

资料来源：[简述一下你对线程池的理解](https://www.toutiao.com/video/7123817991153811975/?from_scene=all)

关于这个问题， 我会从几个方面来回答。

首先， 线程池本质上是一种池化技术， 而池化技术是一种资源复用的思想， 比较常见的有连接池、 内存池、 对象池。而线程池里面复用的是线程资源， 它的核心设计目标， 我认为有两个：
减少线程的频繁创建和销毁带来的性能开销， 因为线程创建会涉及到 CPU 上下文切换、 内存分配等工作。
线程池本身会有参数来控制线程创建的数量， 这样就可以避免无休止的创建线程带来的资源利用率过高的问题。

起到了资源保护的作用。
其次， 我简单说一下线程池里面的线程复用技术。 因为线程本身并不是一个受控的技术， 也就是说线程的生命周期时由任务运行的状态决定的， 无法人为控制。所以为了实现线程的复用， 线程池里面用到了阻塞队列， 简单来说就是线程池里面的工作线程处于一直运行状态， 它会从阻塞队列中去获取待执行的任务， 一旦队列空了， 那这个工作线程就会被阻塞， 直到下次有新的任务进来。
也就是说， 工作线程是根据任务的情况实现阻塞和唤醒， 从而达到线程复用的目的。
最后， 线程池里面的资源限制， 是通过几个关键参数来控制的， 分别是核心线程数、 最大线程数。
核心线程数表示默认长期存在的工作线程， 而最大线程数是根据任务的情况动态  

创建的线程， 主要是提高阻塞队列中任务的处理效率。

![image-20221005170022093](img/image-20221005170022093.png ':size=40%')