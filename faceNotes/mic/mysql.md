### 索引什么时候失效

资料来源：[索引什么时候失效](https://www.toutiao.com/video/7119682545981227534/?from_scene=all)

InnoDB 引擎里面有两种索引类型， 一种是主键索引、 一种是普通索引。
InnoDB 用了 B+树的结构来存储索引数据。
当使用索引列进行数据查询的时候， 最终会到主键索引树中查询对应的数据行进行返回。
理论上来说， 使用索引列查询， 就能很好的提升查询效率， 但是不规范的使用会导致索引失效， 从而无法发挥索引本身的价值。
导致索引失效的情况有很多：
在索引列上做运算， 比如使用函数， Mysql 在生成执行计划的时候， 它是根据统计信息来判断是否要使用索引的。第一种
而在索引列上加函数运算， 导致 Mysql 无法识别索引列， 也就不会再走索引了。
不过从 Mysql8 开始， 增加了函数索引可以解决这个问题。

第二种：

在一个由多列构成的组合索引中， 需要按照最左匹配法则， 也就是从索引的最左列开始顺序检索， 否则不会走索引。
在组合索引中， 索引的存储结构是按照索引列的顺序来存储的， 因此在 sql 中也需要按照这个顺序才能进行逐一匹配。
否则 InnoDB 无法识别索引导致索引失效。

第三种：

当索引列存在隐式转化的时候， 比如索引列是字符串类型， 但是在 sql 查询中没有使用引号。<br/>

第四种：

那么 Mysql 会自动进行类型转化， 从而导致索引失效在索引列使用不等于号、not 查询的时候， 由于索引数据的检索效率非常低， 因此 Mysql 引擎会判断不走索引。

第五种：

使用`  like ` 通配符匹配后缀` %xxx ` 的时候， 由于这种方式不符合索引的最左匹配原则，所以也不会走索引。

但是反过来， 如果通配符匹配的是前缀`  xxx%` ， 符合最左匹配， 也会走索引。

第六种：

使用` or `连接查询的时候， ` or ` 语句前后没有同时使用索引， 那么索引会失效。 只有` or `左右查询字段都是索引列的时候， 才会生效。
除了这些场景以外， 对于多表连接查询的场景中， 连接顺序也会影响索引的使用。
不过最终是否走索引， 我们可以使用 explain 命令来查看 sql 的执行计划， 然后针对性的进行调优即可

### Mysql索引优点和缺点

资料来源：[Mysql索引优点和缺点](https://www.toutiao.com/video/7096306391794745892/)

索引， 是一种能够帮助 Mysql 高效从磁盘上检索数据的一种数据结构。
在 Mysql 中的 InnoDB 引擎中， 采用了 B+树的结构来实现索引和数据的存储

![image-20221005210708343](img/image-20221005210708343.png ':size=60%')

在我看来， Mysql 里面的索引的优点有很多<br/>
通过 B+树的结构来存储数据， 可以大大减少数据检索时的磁盘 IO 次数， 从而提升数据查询的性能<br/>
B+树索引在进行范围查找的时候， 只需要找到起始节点， 然后基于叶子节点的链表结构往下读取即可， 查询效率较高。<br/>
通过唯一索引约束， 可以保证数据表中每一行数据的唯一性<br/>
当然， 索引的不合理使用， 也会有带来很多的缺点。<br/>
数据的增加、 修改、 删除， 需要涉及到索引的维护， 当数据量较大的情况下， 索引的维护会带来较大的性能开销<br/>
一个表中允许存在一个聚簇索引和多个非聚簇索引， 但是索引数不能创建太多，否则造成的索引维护成本过高。<br/>
创建索引的时候， 需要考虑到索引字段值的分散性， 如果字段的重复数据过多，创建索引反而会带来性能降低。<br/>
在我看来， 任何技术方案都会有两面性， 大部分情况下， 技术方案的选择更多的是看中它的优势和当前问题的匹配度<br/>

### Mysql为什么使用B+Tree作为索引结构？

资料来源：[Mysql为什么使用B+Tree作为索引结构？](https://www.toutiao.com/video/7091921684218774053/?from_scene=all)

一个工作 8 年的粉丝私信了我一个问题。  

他说这个问题是去阿里面试的时候被问到的， 自己查了很多资料也没搞明白， 希
望我帮他解答。
问题是： “Mysql 为什么使用 B+Tree 作为索引结构”
关于这个问题， 看看普通人和高手的回答。
普通人
高手
关于这个问题， 我从几个方面来回答。
首先， 常规的数据库存储引擎，一般都是采用 B 树或者 B+树来实现索引的存储。
因为 B 树是一种多路平衡树， 用这种存储结构来存储大量数据， 它的整个高度会相比二叉树来说， 会矮很多。
而对于数据库来说， 所有的数据必然都是存储在磁盘上的， 而磁盘 IO 的效率实际上是很低的， 特别是在随机磁盘 IO 的情况下效率更低。
所以树的高度能够决定磁盘 IO 的次数， 磁盘 IO 次数越少， 对于性能的提升就越大， 这也是为什么采用 B 树作为索引存储结构的原因   

![image-20231225163439623](img/image-20231225163439623.png)

但是在 Mysql 的 InnoDB 存储引擎里面， 它用了一种增强的 B 树结构， 也就是
B+树来作为索引和数据的存储结构。
相比较于 B 树结构， B+树做了几个方面的优化。
B+树的所有数据都存储在叶子节点， 非叶子节点只存储索引。
叶子节点中的数据使用双向链表的方式进行关联  

![image-20231225163506069](img/image-20231225163506069.png)

使用 B+树来实现索引的原因， 我认为有几个方面。
B+树非叶子节点不存储数据， 所以每一层能够存储的索引数量会增加， 意味着
B+树在层高相同的情况下存储的数据量要比 B 树要多， 使得磁盘 IO 次数更少。
在 Mysql 里面， 范围查询是一个比较常用的操作， 而 B+树的所有存储在叶子节点的数据使用了双向链表来关联， 所以在查询的时候只需查两个节点进行遍历就行， 而 B 树需要获取所有节点， 所以 B+树在范围查询上效率更高。
在数据检索方面， 由于所有的数据都存储在叶子节点， 所以 B+树的 IO 次数会更加稳定一些。
因为叶子节点存储所有数据， 所以 B+树的全局扫描能力更强一些， 因为它只需要扫描叶子节点。 但是 B 树需要遍历整个树  

另外， 基于 B+树这样一种结构， 如果采用自增的整型数据作为主键， 还能更好的避免增加数据的时候， 带来叶子节点分裂导致的大量运算的问题。
总的来说， 我认为技术方案的选型， 更多的是去解决当前场景下的特定问题， 并不一定是说 B+树就是最好的选择， 就像 MongoDB 里面采用 B 树结构， 本质上来说， 其实是关系型数据库和非关系型数据库的差异。
以上就是我对这个问题的理解。
##### 面试点评
对于“为什么要选择 xx 技术”的问题， 其实很好回答。
只要你对这个技术本身的特性足够了解， 那么自然就知道为什么要这么设计。
就像， 我们在业务开发中， 知道什么时候使用 List， 什么时候使用 Map， 道理是一样的  

好的， 本期的普通人 VS 高手面试系列的视频就到这里结束了。
如果有任何面试问题、 职业发展问题、 学习问题， 都可以私信我。
我是 Mic， 一个工作了 14 年的 Java 程序员， 咱们下期再见  


### 谈谈你对B树和B+树的理解？

资料来源：[谈谈你对B树和B+树的理解](https://www.toutiao.com/video/7076388733272588807/?from_scene=all)

数据结构与算法问题， 困扰了无数的小伙伴。
很多小伙伴对数据结构与算法的认知有一个误区， 认为工作中没有用到， 为什么面试要问， 问了能解决实际问题？
图灵奖获得者： Niklaus Wirth 说过： 程序=数据结构+算法， 也就说我们无时无刻都在和数据结构打交道  

只是作为 Java 开发， 由于技术体系的成熟度较高， 使得大部分人认为： 程序应该等于框架+SQL 呀？
今天我们就来分析一道数据结构的题目： ”B 树和 B+树“。
关于这个问题， 我们来看看普通人和高手的回答！

#### 普通人
嗯.我想想…嗯…Mysql 里面好像是用了 B+树来做索引的！ 然后…  

#### 高手

为了更清晰的解答这个问题， 我打算从三个方面来回答：
了解二叉树、 AVL 树、 B 树的概念
B 树和 B+树的应用场景
B 树是一种多路平衡查找树， 为了更形象的理解。
二叉树， 每个节点支持两个分支的树结构， 相比于单向链表， 多了一个分支。
二叉查找树， 在二叉树的基础上增加了一个规则， 左子树的所有节点的值都小于
它的根节点， 右子树的所有子节点都大于它的根节点  二叉查找树会出现斜树问题， 导致时间复杂度增加， 因此又引入了一种平衡二叉树， 它具有二叉查找树的所有特点， 同时增加了一个规则： ”它的左右两个子树的高度差的绝对值不超过 1“。 平衡二叉树会采用左旋、 右旋的方式来实现平衡， 而 B 树是一种多路平衡查找树， 它满足平衡二叉树的规则， 但是它可以有多个子树， 子树的数量取决于关键字的数量， 比如这个图中根节点有两个关键字 3和 5， 那么它能够拥有的子路数量=关键字数+1。
因此从这个特征来看， 在存储同样数据量的情况下， 平衡二叉树的高度要大于 B树。    

![image-20231225155918373](img/image-20231225155918373.png)

![image-20231225160007776](img/image-20231225160007776.png)



![image-20231225160108422](img/image-20231225160108422.png)

B+树， 其实是在 B 树的基础上做的增强， 最大的区别有两个：

B 树的数据存储在每个节点上， 而 B+树中的数据是存储在叶子节点， 并且通过链表的方式把叶子节点中的数据进行连接。
B+树的子路数量等于关键字数

这个是 B 树的存储结构， 从 B 树上可以看到每个节点会存储数据。  

![image-20231225160204712](img/image-20231225160204712.png)



这个是 B+树， B+树的所有数据是存储在叶子节点， 并且叶子节点的数据是用双向链表关联的  

![image-20231225160238153](img/image-20231225160238153.png)

B 树和 B+树， 一般都是应用在文件系统和数据库系统中， 用来减少磁盘 IO 带来的性能损耗。
以 Mysql 中的 InnoDB 为例， 当我们通过 select 语句去查询一条数据时， InnoDB需要从磁盘上去读取数据， 这个过程会涉及到磁盘 IO 以及磁盘的随机 IO
我们知道磁盘 IO 的性能是特别低的， 特别是随机磁盘 IO。
因为， 磁盘 IO 的工作原理是， 首先系统会把数据逻辑地址传给磁盘， 磁盘控制电路按照寻址逻辑把逻辑地址翻译成物理地址， 也就是确定要读取的数据在哪个磁道， 哪个扇区。
为了读取这个扇区的数据， 需要把磁头放在这个扇区的上面， 为了实现这一个点，磁盘会不断旋转， 把目标扇区旋转到磁头下面， 使得磁头找到对应的磁道， 这里涉及到寻道事件以及旋转时间。  

![image-20231225160324455](img/image-20231225160324455.png)



很明显， 磁盘 IO 这个过程的性能开销是非常大的， 特别是查询的数据量比较多的情况下。
所以在 InnoDB 中， 干脆对存储在磁盘块上的数据建立一个索引， 然后把索引数据以及索引列对应的磁盘地址， 以 B+树的方式来存储。
如图所示， 当我们需要查询目标数据的时候， 根据索引从 B+树中查找目标数据即可， 由于 B+树分路较多， 所以只需要较少次数的磁盘 IO 就能查找到。

![image-20231225160354204](img/image-20231225160354204.png)

为什么用 B 树或者 B+树来做索引结构？ 原因是 AVL 树的高度要比 B 树的高度要高， 而高度就意味着磁盘 IO 的数量。 所以为了减少磁盘 IO 的次数， 文件系统或者数据库才会采用 B 树或者 B+树。
以上就是我对 B 树和 B+树的理解！  

#### 结尾
数据结构在实际开发中非常常见， 比如数组、 链表、 双向链表、 红黑树、 跳跃表、B 树、 B+树、 队列等。
在我看来， 数据结构是编程中最重要的基本功之一。
学了顺序表和链表， 我们就能知道查询操作比较多的场景中应该用顺序表， 修改操作比较多的场景应该使用链表。
学了队列之后， 就知道对于 FIFO 的场景中， 应该使用队列。
学了树的结构后， 会发现原来查找类的场景， 还可以更进一步提升查询性能。
基本功决定大家在技术这个岗位上能够走到的高度。  



### 索引的底层实现为什么选择B+Tree而不是红黑树？

资料来源：[索引的底层实现为什么选择B+Tree而不是红黑树？](https://www.toutiao.com/video/7028890535587021326/)



<hr/>


### Mysql的事务隔离级别

资料来源：[Mysql的事务隔离级别](https://www.toutiao.com/video/7091535865247498783/?from_scene=all)

好的， 关于这个问题， 我会从几个方面来回答。<br/>
首先， 事务隔离级别， 是为了解决多个并行事务竞争导致的数据安全问题的一种规范。<br/>
具体来说， 多个事务竞争可能会产生三种不同的现象。<br/>
假设有两个事务 T1/T2 同时在执行， T1 事务有可能会读取到 T2 事务未提交的数据， 但是未提交的事务 T2 可能会回滚， 也就导致了 T1 事务读取到最终不一
定存在的数据产生脏读的现象<br/>

![image-20221005212627759](img/image-20221005212627759.png ':size=60%')<br/>

假设有两个事务 T1/T2 同时执行， 事务 T1 在不同的时刻读取同一行数据的时候结果可能不一样， 从而导致不可重复读的问题<br/>

![image-20221005212722813](img/image-20221005212722813.png  ':size=60%')<br/>

假设有两个事务 T1/T2 同时执行， 事务 T1 执行范围查询或者范围修改的过程中， 事务 T2 插入了一条属于事务 T1 范围内的数据并且提交了， 这时候在事
务 T1 查询发现多出来了一条数据， 或者在 T1 事务发现这条数据没有被修改，看起来像是产生了幻觉， 这种现象称为幻读<br/>

![image-20221005213030978](img/image-20221005213030978.png  ':size=60%')<br/>

而这三种现象在实际应用中， 可能有些场景不能接受某些现象的存在， 所以在SQL 标准中定义了四种隔离级别， 分别是：<br/>
`读未提交`， 在这种隔离级别下， 可能会产生脏读、 不可重复读、 幻读。
`读已提交（RC)`， 在这种隔离级别下， 可能会产生不可重复读和幻读。
`可重复读（RR）` ， 在这种隔离级别下， 可能会产生幻读
`串行化`， 在这种隔离级别下， 多个并行事务串行化执行， 不会产生安全性问题。
这四种隔离级别里面， 只有串行化解决了全部的问题， 但也意味着这种隔离级别的性能是最低的。
在 Mysql 里面， InnoDB 引擎默认的隔离级别是 RR（可重复读） ， 因为它需要保证事务 ACID 特性中的隔离性特征。
以上就是我对这个问题的理解。


### 存储MD5的值应该用VARCHAR还是CHAR？

我认为应该是用char类型，char类型是一个固定长度的字符串。varchar是一个可变长度的字符串。而md5算法，它所产生的这个数字，他是一个固定长度的。不管数据怎么修改，长度是不变的。这个点呢非常符合char类型的一个特征。另外由于规定长度的，所以在数据变更的时候。不需要进行调整存储空间的一个大小，在效率上会比varchar要更好一些。

###  Mysql中MyISAM和InnoDB引擎有什么区别？
资料来源:[Mysql中MyISAM和InnoDB引擎有什么区别？](https://www.toutiao.com/article/7147518399751701022/)

MyISAM和InnoDB都是Mysql里面的两个存储引擎。

在Mysql里面，存储引擎是可以自己扩展的，它的本质其实是定义数据存储的方式以及数据读取的实现逻辑。

而不同存储引擎本身的特性，使得我们可以针对性的选择合适的引擎来实现不同的业务场景。

从而获得更好的性能。

在Mysql 5.5之前，默认的存储引擎是MyISAM，从5.5以后，InnoDB就作为了默认的存储引擎。

在实际应用开发中，我们基本上都是采用InnoDB引擎。

我们先来看一下MyISAM引擎。

MyISAM引擎的数据是通过二进制的方式存储在磁盘上，它在磁盘上体现为两个文件

- 一个是.MYD文件，D代表Data，是MyISAM的数据文件，存放数据记录，
- 一个是.MYI文件，I代表Index，是MyISAM的索引文件，存放索引

实现机制如图所示。

因为索引和数据是分离的，所以在进行查找的时候，先从索引文件中找到数据的磁盘位置，再到数据文件中找到索引对应的数据内容。

![1](img/1.png)

在InnoDB存储引擎中，数据同样存储在磁盘上，它在磁盘上只有一个ibd文件，里面包含索引和数据。

它的整体结构如图所示，在B+树的叶子节点里面存储了索引对应的数据，在通过索引进行检索的时候，命中叶子节点，就可以直接从叶子节点中取出行数据。

![2](img/2.png)



了解了这两个存储引擎以后，我们在面试的时候该怎么回答呢？

基于我的理解，我认为MyISAm和InnoDB的区别有4个，

- 第一个，数据存储的方式不同，MyISAM中的数据和索引是分开存储的，而InnoDB是把索引和数据存储在同一个文件里面。
- 第二个，对于事务的支持不同，MyISAM不支持事务，而InnoDB支持ACID特性的事务处理
- 第三个，对于锁的支持不同，MyISAM只支持表锁，而InnoDB可以根据不同的情况，支持行锁，表锁，间隙锁，临键锁
- 第四个，MyISAM不支持外键，InnoDB支持外键

因此基于这些特性，我们在实际应用中，可以根据不同的场景来选择合适的存储引擎。
比如如果需要支持事务，那必须要选择InnoDB。
如果大部分的表操作都是查询，可以选择MyISAM。

### Mysql如何解决幻读问题？

资料来源：[Mysql如何解决幻读问题？](https://www.toutiao.com/video/7130449294322041351/)

前天有个去快手面试的小伙伴私信我， 他遇到了这样一个问题： “InnoDB 如何解决幻读”？
这个问题确实不是很好回答， 在实际应用中， 很多同学几乎都不关注数据库的事务隔离性。
所有问题基本就是 CRUD， 一把梭~
那么今天， 我们看一下关于“InnoDB 如何解决幻读”这个问题， 普通人和高手的回答  

#### 普通人
嗯， 我印象中， 幻读是通过 MVCC 机制来解决的， 嗯....
MVCC 类似于一种乐观锁的机制， 通过版本的方式来区分不同的并发事务， 避免幻读问题  

#### 高手

我会从三个方面来回答：

1、 Mysql 的事务隔离级别
Mysql 有四种事务隔离级别， 这四种隔离级别代表当存在多个事务并发冲突时，可能出现的脏读、 不可重复读、 幻读的问题。
其中 InnoDB 在 RR 的隔离级别下， 解决了幻读的问题  

![image-20231225160729150](img/image-20231225160729150.png)

2、 什么是幻读？
那么， 什么是幻读呢？
幻读是指在同一个事务中， 前后两次查询相同的范围时， 得到的结果不一致
第一个事务里面我们执行了一个范围查询， 这个时候满足条件的数据只有一条
第二个事务里面， 它插入了一行数据， 并且提交了
接着第一个事务再去查询的时候， 得到的结果比第一查询的结果多出来了一条数据。  

![image-20231225160806835](img/image-20231225160806835.png)4

所以， 幻读会带来数据一致性问题。
3、 InnoDB 如何解决幻读的问题
InnoDB 引入了间隙锁和 next-key Lock 机制来解决幻读问题， 为了更清晰的说明这两种锁， 我举一个例子：
假设现在存在这样这样一个 B+Tree 的索引结构， 这个结构中有四个索引元素分别是： 1、 4、 7、 10。  

![image-20231225160837696](img/image-20231225160837696.png)

当我们通过主键索引查询一条记录， 并且对这条记录通过 for update 加锁  

![image-20231225160915037](img/image-20231225160915037.png)

这个时候， 会产生一个记录锁， 也就是行锁， 锁定 id=1 这个索引。

![image-20231225160947104](img/image-20231225160947104.png)



被锁定的记录在锁释放之前， 其他事务无法对这条记录做任何操作。
前面我说过对幻读的定义： 幻读是指在同一个事务中， 前后两次查询相同的范围时， 得到的结果不一致！
注意， 这里强调的是范围查询，
也就是说， InnoDB 引擎要解决幻读问题， 必须要保证一个点， 就是如果一个事务通过这样一条语句进行锁定时。  

![image-20231225161020917](img/image-20231225161020917.png)

另外一个事务再执行这样一条 insert 语句， 需要被阻塞， 直到前面获得锁的事务释放。  

![image-20231225161052772](img/image-20231225161052772.png)

所以， 在 InnoDB 中设计了一种间隙锁， 它的主要功能是锁定一段范围内的索引记录
当对查询范围 `id>4 and id<7 `加锁的时候， 会针对 B+树中（4， 7） 这个开区间范围的索引加间隙锁。
意味着在这种情况下， 其他事务对这个区间的数据进行插入、 更新、 删除都会被锁住。  

![image-20231225161128963](img/image-20231225161128963.png)

但是， 还有另外一种情况， 比如像这样

![image-20231225161142348](img/image-20231225161142348.png)

这条查询语句是针对 id>4 这个条件加锁， 那么它需要锁定多个索引区间， 所以在这种情况下 InnoDB 引入了 next-key Lock 机制。
next-key Lock 相当于间隙锁和记录锁的合集， 记录锁锁定存在的记录行， 间隙锁锁住记录行之间的间隙， 而 next-key Lock 锁住的是两者之和。  

![image-20231225161646871](img/image-20231225161646871.png)

每个数据行上的非唯一索引列上都会存在一把 next-key lock， 当某个事务持有该数据行的 next-key lock 时， 会锁住一段左开右闭区间的数据。

因此， 当通过 id>4 这样一种范围查询加锁时， 会加 next-key Lock， 锁定的区间范围是： (4,7],(7,10],(10,+∞]  

![image-20231225161714482](img/image-20231225161714482.png)

间隙锁和 next-key Lock 的区别在于加锁的范围， 间隙锁只锁定两个索引之间的引用间隙， 而 next-key Lock 会锁定多个索引区间， 它包含记录锁和间隙锁。
当我们使用了范围查询， 不仅仅命中了 Record 记录， 还包含了 Gap 间隙， 在这种情况下我们使用的就是临键锁， 它是 MySQL 里面默认的行锁算法。
4、 总结
虽然 InnoDB 中通过间隙锁的方式解决了幻读问题， 但是加锁之后一定会影响到并发性能， 因此， 如果对性能要求较高的业务场景中， 可以把隔离级别设置成RC， 这个级别中不存在间隙锁。
以上就是我对于 innoDB 如何解决幻读问题的理解！  

### 数据库连接池有什么用？以及它有哪些关键参数?

资料来源：[数据库连接池有什么用？以及它有哪些关键参数?](https://www.toutiao.com/video/7091921684218774053/?from_scene=all)

一个工作 5 年的粉丝找到我， 他说参加美团面试， 遇到一个基础题没回答上来。
这个问题是： “数据库连接池有什么用？ 以及它有哪些关键参数”？
我说， 这个问题都不知道， 那你项目里面的连接池配置怎么设置的？ 你们猜他怎么回答。 懂得懂得啊。
好的， 关于这个问题， 我们来看看普通人和高手的回答。  

#### 普通人
#### 高手

关于这个问题， 我从这几个方面来回答。
首先， 数据库连接池是一种池化技术， 池化技术的核心思想是实现资源的复用，避免资源重复创建销毁的开销。
而在数据库的应用场景里面， 应用程序每次向数据库发起 CRUD 操作的时候，都需要创建连接
在数据库访问量较大的情况下， 频繁的创建连接会带来较大的性能开销。
而连接池的核心思想， 就是应用程序在启动的时候提前初始化一部分连接保存
到连接池里面， 当应用需要使用连接的时候， 直接从连接池获取一个已经建立好的链接。
连接池的设计， 避免了每次连接的建立和释放带来的开销。  

![image-20231225163039650](img/image-20231225163039650.png)

连接池的参数有很多， 不过关键参数就几个：
首先是， 连接池初始化的时候会有几个关键参数：
初始化连接数， 表示启动的时候初始多少个连接保存到连接池里面。
最大连接数， 表示同时最多能支持多少连接， 如果连接数不够， 后续要获取连接的线程会阻塞。
最大空闲连接数， 表示没有请求的时候， 连接池中要保留的最大空闲连接。
最小空闲连接， 当连接数小于这个值的时候， 连接池需要再创建连接来补充到这个值。
然后， 就是在使用连接的时候的关键参数：  

最大等待时间， 就是连接池里面的连接用完了以后， 新的请求要等待的时间， 超过这个时间就会提示超时异常。
无效连接清除， 清理连接池里面的无效连接， 避免使用这个连接操作的时候出现错误。
不同的连接池框架， 除了核心的参数以外， 还有很多业务型的参数， 比如是否要
检测连接 sql 的有效性、 连接初始化 SQL 等等， 这些配置参数可以在使用的时
候去查询 api 文档就可以知道。
以上就是我对这个问题的理解  

#### 面试点评

这个问题更进一步去问， 就会问到最大连接数、 最小连接数应该如何设置？
连接池的实现原理啊等等。
所以建议各位粉丝还是要有一个系统化的学习。
好的， 本期的普通人 VS 高手面试系列的视频就到这里结束了。
如果有任何面试问题、 职业发展问题、 学习问题， 都可以私信我。
我是 Mic， 一个工作了 14 年的 Java 程序员， 咱们下期再见。  

### 为什么阿里Java手册，禁止使用存储过程？

资料来源：[【Java面试】为什么阿里Java手册，禁止使用存储过程？](https://www.toutiao.com/video/7254097421586661945/?from_scene=all)



### 5年架构师都是这么回答，Redis遇到Hash冲突怎么办？

资料来源：[【Java面试】5年架构师都是这么回答，Redis遇到Hash冲突怎么办？](https://www.toutiao.com/video/7222929409823474213/)

<hr/>


### Mysql索引有哪些缺点，以及具有哪些索引类型？

资料来源：[【Java面试】Mysql索引有哪些缺点，以及具有哪些索引类型？](https://www.toutiao.com/video/7101505375253299748/?from_scene=all)






### Redis 和 Mysql 如何保证数据一致性

资料来源：[Java面试面试必问，Redis和Mysql如何保证数据一致性？-今日头条 (toutiao.com)](https://www.toutiao.com/video/7207336786626871866/)

今天分享一道一线互联网公司高频面试题。
“Redis 和 Mysql 如何保证数据一致性”。
这个问题难倒了不少工作 5 年以上的程序员， 难的不是问题本身， 而是解决这个
问题的思维模式。
下面来看看普通人和高手对于这个问题的回答  

#### 普通人
嗯....
Redis 和 Mysql 的数据一致性保证是吧？ 我想想。
嗯， 就是， Mysql 的数据发生变化以后， 可以同步修改 Redis 里面的数据。  

#### 高手
一般情况下， Redis 用来实现应用和数据库之间读操作的缓存层， 主要目的是减少数据库 IO， 还可以提升数据的 IO 性能。
这是它的整体架构。
当应用程序需要去读取某个数据的时候， 首先会先尝试去 Redis 里面加载， 如果命中就直接返回。 如果没有命中， 就从数据库查询， 查询到数据后再把这个数据缓存到 Redis 里面。  

![image-20231225162031471](img/image-20231225162031471.png)

在这样一个架构中， 会出现一个问题， 就是一份数据， 同时保存在数据库和 Redis里面， 当数据发生变化的时候， 需要同时更新 Redis 和 Mysql， 由于更新是有先后顺序的， 并且它不像 Mysql 中的多表事务操作， 可以满足 ACID 特性。 所以就会出现数据一致性问题。  

![image-20231225162119436](img/image-20231225162119436.png)

在这种情况下， 能够选择的方法只有几种。
先更新数据库， 再更新缓存
先删除缓存， 再更新数据库
如果先更新数据库， 再更新缓存， 如果缓存更新失败， 就会导致数据库和 Redis中的数据不一致  

![image-20231225162153221](img/image-20231225162153221.png)

如果是先删除缓存， 再更新数据库， 理想情况是应用下次访问 Redis 的时候， 发现 Redis 里面的数据是空的， 就从数据库加载保存到 Redis 里面， 那么数据是一致的。 但是在极端情况下， 由于删除 Redis 和更新数据库这两个操作并不是原子的， 所以这个过程如果有其他线程来访问， 还是会存在数据不一致问题。  

![image-20231225162600538](img/image-20231225162600538.png)

所以， 如果需要在极端情况下仍然保证 Redis 和 Mysql 的数据一致性， 就只能采用最终一致性方案。
比如基于 RocketMQ 的可靠性消息通信， 来实现最终一致性。  

![image-20231225162632547](img/image-20231225162632547.png)

还可以直接通过 Canal 组件， 监控 Mysql 中 binlog 的日志， 把更新后的数据同步到 Redis 里面。  

![image-20231225162700853](img/image-20231225162700853.png)

因为这里是基于最终一致性来实现的， 如果业务场景不能接受数据的短期不一致性， 那就不能使用这个方案来做。
以上就是我对这个问题的理解。
#### 结尾
在面试的时候， 面试官喜欢问各种没有场景化的纯粹的技术问题， 比如说： “你这个最终一致性方案”还是会存在数据不一致的问题啊？ 那怎么解决？
先不用慌， 技术是为业务服务的， 所以不同的业务场景， 对于技术的选择和方案的设计都是不同的， 所以这个时候， 可以反问面试官， 具体的业务场景是什么？
一定要知道的是， 一个技术方案不可能 cover 住所有的场景， 明白了吗？  