### ReentrantLock是如何实现锁公平和非公平性的

资料来源：[ReentrantLock是如何实现锁公平和非公平性的](https://www.toutiao.com/video/7103772817413374500/?from_scene=all)

#### 回答：

我先解释一下个公平和非公平的概念。
公平， 指的是竞争锁资源的线程， 严格按照请求顺序来分配锁。
非公平， 表示竞争锁资源的线程， 允许插队来抢占锁资源。
ReentrantLock 默认采用了非公平锁的策略来实现锁的竞争逻辑。
其次， ReentrantLock 内部使用了 AQS 来实现锁资源的竞争，  

没有竞争到锁资源的线程， 会加入到 AQS 的同步队列里面， 这个队列是一个FIFO 的双向链表。  

![image-20221005164300424](img/image-20221005164300424.png  ':size=60%')

在这样的一个背景下， 公平锁的实现方式就是， 线程在竞争锁资源的时候判断AQS 同步队列里面有没有等待的线程。
如果有， 就加入到队列的尾部等待。
而非公平锁的实现方式， 就是不管队列里面有没有线程等待， 它都会先去尝试抢占锁资源， 如果抢不到， 再加入到 AQS 同步队列等待。
ReentrantLock 和 Synchronized 默认都是非公平锁的策略， 之所以要这么设计，
我认为还是考虑到了性能这个方面的原因。
因为一个竞争锁的线程如果按照公平的策略去阻塞等待， 同时 AQS 再把等待队列里面的线程唤醒， 这里会涉及到内核态的切换， 对性能的影响比较大。
如果是非公平策略， 当前线程正好在上一个线程释放锁的临界点抢占到了锁， 就意味着这个线程不需要切换到内核态， 虽然对原本应该要被唤醒的线程不公平，
但是提升了锁竞争的性能。
以上就是我对这个问题的理解。  

### Java官方提供了哪几种线程池，分别有什么特点？

资料来源：[Java官方提供了哪几种线程池，分别有什么特点？](https://www.toutiao.com/video/7123817991153811975/?from_scene=all)

#### 介绍：

> “Java 官方提供了哪几种线程池， 分别有什么特点？ ”
> 这是一道针对工作 3 年左右的面试题， 屏幕前的小伙伴， 你能回答上来吗？  

#### 回答
JDK 中幕刃提供了 5 中不同线程池的创建方式， 下面我分别说一下每一种线程池以及它的特点。
**newCachedThreadPool**， 是一种可以缓存的线程池， 它可以用来处理大量短期的突发流量。
它的特点有三个， 最大线程数是 Integer.MaxValue， 线程存活时间是 60 秒， 阻塞队列用的是 SynchronousQueue， 这是一种不存才任何元素的阻塞队列， 也就是每提交一个任务给到线程池， 都会分配一个工作线程来处理， 由于最大线程数没有限制。所以它可以处理大量的任务， 另外每个工作线程又可以存活 60s， 使得这些工作线程可以缓存起来应对更多任务的处理。

**newFixedThreadPool**， 是一种固定线程数量的线程池。它的特点是核心线程和最大线程数量都是一个固定的值如果任务比较多工作线程处理不过来， 就会加入到阻塞队列里面等待。

**newSingleThreadExecutor**， 只有一个工作线程的线程池。并且线程数量无法动态更改， 因此可以保证所有的任务都按照 FIFO 的方式顺序执行。

**newScheduledThreadPool**， 具有延迟执行功能的线程池可以用它来实现定时调度

**newWorkStealingPool**， Java8 里面新加入的一个线程池它内部会构建一个 ForkJoinPool， 利用工作窃取的算法并行处理请求。
这些线程都是通过工具类 Executors 来构建的， 线程池的最终实现类是ThreadPoolExecutor。  

### 简述一下你对线程池的理解

资料来源：[简述一下你对线程池的理解](https://www.toutiao.com/video/7123817991153811975/?from_scene=all)

关于这个问题， 我会从几个方面来回答。

首先， 线程池本质上是一种池化技术， 而池化技术是一种资源复用的思想， 比较常见的有连接池、 内存池、 对象池。而线程池里面复用的是线程资源， 它的核心设计目标， 我认为有两个：
减少线程的频繁创建和销毁带来的性能开销， 因为线程创建会涉及到 CPU 上下文切换、 内存分配等工作。
线程池本身会有参数来控制线程创建的数量， 这样就可以避免无休止的创建线程带来的资源利用率过高的问题。

起到了资源保护的作用。
其次， 我简单说一下线程池里面的线程复用技术。 因为线程本身并不是一个受控的技术， 也就是说线程的生命周期时由任务运行的状态决定的， 无法人为控制。所以为了实现线程的复用， 线程池里面用到了阻塞队列， 简单来说就是线程池里面的工作线程处于一直运行状态， 它会从阻塞队列中去获取待执行的任务， 一旦队列空了， 那这个工作线程就会被阻塞， 直到下次有新的任务进来。
也就是说， 工作线程是根据任务的情况实现阻塞和唤醒， 从而达到线程复用的目的。
最后， 线程池里面的资源限制， 是通过几个关键参数来控制的， 分别是核心线程数、 最大线程数。
核心线程数表示默认长期存在的工作线程， 而最大线程数是根据任务的情况动态  

创建的线程， 主要是提高阻塞队列中任务的处理效率。

![image-20221005170022093](img/image-20221005170022093.png ':size=60%')

### 简述一下你对线程池的理解

资料来源：[什么是守护线程，它有什么特点？](https://www.toutiao.com/video/7101505375253299748/?from_scene=all)

守护线程， 它是一种专门为用户线程提供服务的线程， 它的生命周期依赖于用户线程。<br/>
只有 JVM 中仍然还存在用户线程正在运行的情况下， 守护线程才会有存在的意义。<br/>
否则， 一旦 JVM 进程结束， 那守护线程也会随之结束。<br/>
也就是说， 守护线程不会阻止 JVM 的退出。 但是用户线程会！<br/>
守护线程和用户线程的创建方式是完全相同的， 我们只需要调用用户线程里面的setDaemon 方法并且设置成 true， 就表示这个线程是守护线程。<br/>
因为守护线程拥有自己结束自己生命的特性， 所以它适合用在一些后台的通用服务场景里面。<br/>
比如 JVM 里面的垃圾回收线程， 就是典型的使用场景。<br/>
这个场景的特殊之处在于， 当 JVM 进程技术的时候， 内存回收线程存在的意义也就不存在了。<br/>
所以不能因为正在进行垃圾回收导致 JVM 进程无法技术的问题。<br/>
但是守护线程不能用在线程池或者一些 IO 任务的场景里面， 因为一旦 JVM 退出之后， 守护线程也会直接退出。<br/>
就会可能导致任务没有执行完或者资源没有正确释放的问题。

### 如果一个线程两次调用start()，会出现什么问题？

资料来源：[如果一个线程两次调用start()，会出现什么问题？](https://www.toutiao.com/video/7101505375253299748/?from_scene=all)

在 Java 里面， 一个线程只能调用一次 start() 方法， 第二次调用会抛出IllegalThreadStateException。
一个线程本身是具备一个生命周期的。
在 Java 里面， 线程的生命周期包括 6 种状态。
**NEW**， 线程被创建还没有调用 start 启动<br/>
**RUNNABLE**， 在这个状态下的线程有可能是正在运行， 也可能是在就绪队列里
面等待操作系统进行调度分配 CPU 资源。<br/>
**BLOCKED**， 线程处于锁等待状态。<br/>
**WAITING**， 表示线程处于条件等待状态， 当触发条件后唤醒， 比如 wait/notify。<br/>
**TIMED_WAIT**， 和 WAITING 状态相同， 只是它多了一个超时条件触发。<br/>
**TERMINATED**， 表示线程执行结束。<br/>
当我们第一次调用 start()方法的时候， 线程的状态可能处于终止或者非 NEW 状态下的其他状态。<br/>
再调用一次 start()， 相当于让这个正在运行的线程重新运行， 不管从线程的安全性角度， 还是从线程本身的执行逻辑， 都是不合理的。<br/>
因此为了避免这个问题， 在线程运行的时候会先判断当前线程的运行状态。<br/>
以上就是我对这个问题的理解
