


### 谈谈什么是消息队列(MQ)

资料来源：[谈谈什么是消息队列(MQ)](https://www.toutiao.com/video/7031099634365760036/)

#### 普通人
消息用队列的模式发送，
把要传输的数据放在队列中，
产生消息的叫做生产者，
从队列里取出消息的叫做消费者。
这些是我对消息队列的理解  

#### 高手  

消息队列 Message Queue， 简称 MQ。
是一种应用间的通信方式， 主要由三个部分组成。  

![image-20231226152840006](img/image-20231226152840006.png)

**生产者： **Producer
消息的产生者与调用端
主要负责消息所承载的业务信息的实例化
是一个队列的发起方
**代理：**Broker
主要的处理单元
负责消息的存储、 投递、 及各种队列附加功能的实现
是消息队列最核心的组成部分
**消费者： **Consumer

一个消息队列的终端
也是消息的调用端
具体是根据消息承载的信息， 处理各种业务逻辑。 消息队列的应用场景较多，
常用的可以分为三种：
**异步处理**
主要应用于对实时性要求不严格的场景，
比如： 用户注册发送验证码、 下单通知、 发送优惠券等等。
服务方只需要把协商好的消息发送到消息队列，
剩下的由消费消息的服务去处理，
不用等待消费服务返回结果。  

![image-20231226153032873](img/image-20231226153032873.png)

**应用解耦**
应用解耦可以看作是把相关但耦合度不高的系统联系起来。
比如订单系统与 WMS、 EHR 系统， 有关联但不哪么紧密， 每个系统之间只需要把约定的消息发送到 MQ， 另外的系统去消费即可。
解决了各个系统可以采用不同的架构、 语言来实现， 从而大大增加了系统的灵活性。  

![image-20231226153127128](img/image-20231226153127128.png)

**流量削峰**
流量削峰一般应用在大流量入口且短时间内业务需求处理不完的服务中心，为了权衡高可用， 把大量的并行任务发送到 MQ 中，
依据 MQ 的存储及分发功能， 平稳的处理后续的业务，  起到一个大流量缓冲的作用  

![image-20231226153226431](img/image-20231226153226431.png)

目前市面上常见的消息队列中间件主要有
ActiveMQ、 RabbitMQ、 Kafka、 RocketMQ 这几种，在架构技术选型的时候一般根据业务的需求选择合适的中间件：
比如中小型公司， 低吞吐量的一般用 ActiveMQ、 RabbitMQ 较为合适，大数据高吞吐量的大型公司一般选用 Kafka 和 RocketMQ。
以上就是我的 MQ 的理解。  

#### 总结
好的， 看完高手的回答后， 相信每位看完视频的小伙伴对消息队列有了更深刻
的理解 ， 当然本期视频还有很多内容未涉及到， 比如中间件产品的介绍、 消息
队列的实现原理等等， 如果你还想听请在下方的评论区留言， 我会逐步安排  


### RabbitMQ如何实现高可用

资料来源：[RabbitMQ如何实现高可用](https://www.toutiao.com/video/7134958549234680350/?from_scene=all)

### Kafka如何保证消息不丢失？

资料来源：[Kafka如何保证消息不丢失？](https://www.toutiao.com/video/7083432523916640799/?from_scene=all)


### MQ是如何保证消息顺序性

资料来源：[MQ是如何保证消息顺序性](https://www.toutiao.com/video/7106388748878905870/)

### Kafka怎么避免重复消费？

资料来源：[Kafka怎么避免重复消费？](https://www.toutiao.com/video/7099638175949128222/?from_scene=all)

#### 回答：

好的， 关于这问题， 我从几个方面来回答。<br/>
首先， Kafka Broker 上存储的消息， 都有一个 Offset 标记。<br/>
然后 kafka 的消费者是通过 offSet 标记来维护当前已经消费的数据，<br/>
每消费一批数据， Kafka Broker 就会更新 OffSet 的值， 避免重复消费<br/>

![image-20221005212051132](img/image-20221005212051132.png ':size=50%')

默认情况下， 消息消费完以后， 会自动提交 Offset 的值， 避免重复消费。<br/>
Kafka 消费端的自动提交逻辑有一个默认的 5 秒间隔， 也就是说在 5 秒之后的下一次向 Broker 拉取消息的时候提交。<br/>
所以在 Consumer 消费的过程中， 应用程序被强制 kill 掉或者宕机， 可能会导致Offset 没提交， 从而产生重复提交的问题。<br/>
除此之外， 还有另外一种情况也会出现重复消费。在 Kafka 里面有一个 Partition Balance 机制， 就是把多个 Partition 均衡的分配给多个消费者。<br/>
Consumer 端会从分配的 Partition 里面去消费消息， 如果 Consumer 在默认的 5分钟内没办法处理完这一批消息。<br/>
就会触发 Kafka 的 Rebalance 机制， 从而导致 Offset 自动提交失败。<br/>
而在重新 Rebalance 之后， Consumer 还是会从之前没提交的 Offset 位置开始消费， 也会导致消息重复消费的问题。<br/>

![image-20221005212250193](img/image-20221005212250193.png ':size=50%')

基于这样的背景下， 我认为解决重复消费消息问题的方法有几个。<br/>
提高消费端的处理性能避免触发 Balance， 比如可以用异步的方式来处理消息，<br/>
缩短单个消息消费的市场。 或者还可以调整消息处理的超时时间。 还可以减少一次性从 Broker 上拉取数据的条数  <br/>

可以针对消息生成 md5 然后保存到 mysql 或者 redis 里面， 在处理消息之前先去 mysql 或者 redis 里面判断是否已经消费过。 这个方案其实就是利用幂等性的思想。<br/>


###  什么叫阻塞队列的有界和无界?

资料来源：[ 什么叫阻塞队列的有界和无界?](https://www.toutiao.com/video/7075638697248424461/?from_scene=all)

昨天一个 3 年 Java 经验的小伙伴私信我， 他说现在面试怎么这么难啊！
我只是面试一个业务开发， 他们竟然问我： 什么叫阻塞队列的有界和无界。 现在
面试也太卷了吧!
如果你也遇到过类似问题， 那我们来看看普通人和高手的回答吧！  

#### 普通人
有界队列就是说队列中的元素个数是有限制的， 而无界对接表示队列中的元素个数没有限制！ 嗯！ ！ ！  

#### 高手
 阻塞队列， 是一种特殊的队列， 它在普通队列的基础上提供了两个附加功能当队列为空的时候， 获取队列中元素的消费者线程会被阻塞， 同时唤醒生产者线程。
当队列满了的时候， 向队列中添加元素的生产者线程被阻塞， 同时唤醒消费者线程  

![image-20231226161733520](img/image-20231226161733520.png)44

其中， 阻塞队列中能够容纳的元素个数， 通常情况下是有界的， 比如我们实例化一个 ArrayBlockingList， 可以在构造方法中传入一个整形的数字， 表示这个基于数组的阻塞队列中能够容纳的元素个数。 这种就是有界队列。
而无界队列， 就是没有设置固定大小的队列， 不过它并不是像我们理解的那种元素没有任何限制， 而是它的元素存储量很大， 像 LinkedBlockingQueue， 它的默认队列长度是 Integer.Max_Value， 所以我们感知不到它的长度限制。
无界队列存在比较大的潜在风险， 如果在并发量较大的情况下， 线程池中可以几乎无限制的添加任务， 容易导致内存溢出的问题！
以上就是我对这个问题的理解!  

#### 结尾
阻塞队列在生产者消费者模型的场景中使用频率比较高， 比较典型的就是在线程池中， 通过阻塞队列来实现线程任务的生产和消费功能。
基于阻塞队列实现的生产者消费者模型比较适合用在异步化性能提升的场景， 以及做并发流量缓冲类的场景中！  

在很多开源中间件中都可以看到这种模型的使用， 比如在 Zookeeper 源码中就大量用到了阻塞队列实现的生产者消费者模型。
OK， 本期的普通人 VS 高手面试系列的视频就到这里结束了， 喜欢的朋友记得
点赞收藏。
我是 Mic， 一个工作了 14 年的 Java 程序员， 咱们下期再见  

###  基于数组的阻塞队列 ，ArrayBlockingQueue 原理

资料来源：[基于数组的阻塞队列 ，ArrayBlockingQueue 原理](https://www.toutiao.com/video/7084567609114362399/?from_scene=all)

https://www.toutiao.com/video/7075638697248424461/?from_scene=all)

今天来分享一道“饿了么”的高级工程师的面试题。
“基于数组的阻塞队列 ArrayBlockingQueue”的实现原理。
关于这个问题， 我们来看看普通人和高手的回答。  

#### 高手
阻塞队列（BlockingQueue） 是在队列的基础上增加了两个附加操作，
在队列为空的时候， 获取元素的线程会等待队列变为非空。
当队列满时， 存储元素的线程会等待队列可用。  

![image-20231226161947439](img/image-20231226161947439.png)

由于阻塞队列的特性， 可以非常容易实现生产者消费者模型， 也就是生产者只需要关心数据的生产， 消费者只需要关注数据的消费， 所以如果队列满了， 生产者就等待， 同样， 队列空了， 消费者也需要等待。
要实现这样的一个阻塞队列， 需要用到两个关键的技术， 队列元素的存储、 以及线程阻塞和唤醒。
而 ArrayBlockingQueue 是基于数组结构的阻塞队列， 也就是队列元素是存储在一个数组结构里面， 并且由于数组有长度限制， 为了达到循环生产和循环消费的目的， ArrayBlockingQueue 用到了循环数组。
而线程的阻塞和唤醒， 用到了 J.U.C 包里面的 ReentrantLock 和 Condition。Condition 相当于 wait/notify 在 JUC 包里面的实现。
以上就是我对这个问题的理解。  

#### 面试点评
对于原理类的问题， 有些小伙伴找不到切入点， 不知道该怎么回答。
所谓的原理， 通常说的是工作原理， 比如对于 ArrayBlockingQueue 这个问题  

它的作用是在队列的基础上提供了阻塞添加和获取元素的能力， 那么它的工作原
理就是指用了什么设计方法或者技术来实现这样的功能， 我们只要把这个部分说
清楚就可以了。
好的， 本期的普通人 VS 高手面试系列的视频就到这里结束了， 喜欢的朋友记得
点赞和收藏。
另外， 这些面试题我都整理成了笔记， 大家有需要的可以私信获取。
我是 Mic， 一个工作了 14 年的 Java 程序员， 咱们下期再见。  