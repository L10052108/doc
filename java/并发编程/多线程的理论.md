## 多线程理论

### 多线程的状态

- 线程的六种状态
  在jdk中代码
  ![jdk代码](https://tva1.sinaimg.cn/large/e6c9d24ely1h1dxnwsg7yj218e0n60uy.jpg ":size=50%")
  jdk代码

~~~~Java
public enum State {
NEW,
RUNNABLE,
BLOCKED,
WAITING,
TIMED_WAITING,
TERMINATED;
}
~~~~

- 6个状态定义： java.lang.Thread.State


> 1. New：尚未启动的线程的线程状态。
>
>
> 2. Runnable：可运行线程的线程状态，等待CPU调度。
> 3. Blocked：线程阻塞等待监视器锁定的线程状态。
>
> 处于synchronized同步代码块或方法中被阻塞。
>
> 4. Waiting：线程等待的线程状态。
>
> 不带timeout参数的方式调用Object.wait、 Thread.join、 LockSupport.park
>
> 5. Timed Waiting：具有指定等待时间的等待线程的线程状态。下列带超时的方式：
>
> Thread.sleep、 Object.wait、 Thread.join、 LockSupport.parkNanos、 LockSupport.parkUntil
>
> 6. Terminated：终止线程的线程状态。线程正常完成执行或者出现异常

![状态转化](https://tva1.sinaimg.cn/large/e6c9d24ely1h1dxjc71laj20u00hkabm.jpg)

~~~~java
import org.junit.Test;

/**
 * @program: liuwei
 * @description:
 * @author: liuwei
 * @create: 2021-03-02 14:53
 **/
public class ThreadState {
    @Test
    public  void test1() throws Exception{
        // 第一种状态 新建 -> 运行 -> 终止
        Thread thread1 = new Thread(() -> {
            System.out.println("子线程发来贺电。。。");
        });

        System.out.println("1、调用start之前，thread1的状态：" + thread1.getState().toString());   // NEW
        Thread.sleep(2000L);
        thread1.start();
        System.out.println("2、调用start之后，thread1的状态：" + thread1.getState().toString()); // RUNNABLE

        Thread.sleep(4000L);
        System.out.println("3、4s后，thread1的状态：" + thread1.getState().toString());  // TERMINATED
    }

    @Test
    public  void test2() throws Exception{
        System.out.println("########## 第二种状态 新建 -> 运行 ->  等待 ->  运行 ->  终止（sleep方式）##########");
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(5000L);
                System.out.println("3.sleep结束，" + Thread.currentThread().getName() + "当前的状态：" + Thread.currentThread().getState());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread2.start();
        System.out.println("1、调用start 后， thread2状态" + thread2.getState().toString());

        Thread.sleep(2000L);
        System.out.println("等待 2 秒后， thread2状态：" + thread2.getState().toString());
    }

    @Test
    public void test3() throws Exception{
        System.out.println("########## 第二种状态 新建 -> 运行 ->  阻塞 ->  运行 ->  终止（sleep方式）##########\"");

        Thread thread3 = new Thread(() -> {
            System.out.println("2、抢占之前， thread3状态：" + Thread.currentThread().getState().toString());
            synchronized (this.getClass()){
                System.out.println("3、拿到了锁，可以继续执行， thread3的状态：" + Thread.currentThread().getState().toString());
            }
        });

        synchronized (this.getClass()){
            System.out.println("1. 主线程拿到锁， 启动 thread3");
            thread3.start();
            Thread.sleep(5000L);
            System.out.println("3、 threa3的状态：" + thread3.getState().toString());
            Thread.sleep(5000L);
        }
        System.out.println("主程序 释放锁");
    }
}
~~~~

### 线程的停止

想停止一个线程，最先想到的stop方法，在Thread提供了stop方法

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1dxr0rwg1j21aw0o4gop.jpg)

但是可以看到stop方法，已经过时了。不建议使用

?> 为什么不建议使用？

```java
public class StopThreadDemo {

    @Test
    public void test01() throws Exception{
        MyThread myThread = new MyThread();
        myThread.start();

        Thread.sleep(1000L * 1);
        myThread.stop();

        while (myThread.isAlive()){}  // 等待线程结束
        myThread.print();
    }

    class MyThread extends Thread{

        private int i = 0;
        private int j = 0;

        @Override
        public void run() {
            synchronized (this) {
                i++;
                // 休眠2s
                try {
                    Thread.sleep(1000L * 2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                j++;
            }
        }

        public void print(){
            System.out.println("i=" + i + " ,j=" + j);
        }

    }
}
```

下面的是运行的结果

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1dyaer88ej20z404y3yx.jpg)

从代码中看到使用synchoronized同步锁，希望i和j 是单元操作。但是运行的结果是i++ 执行了，但是j++ 没有执行。导致同步锁失效

**推荐使用 **interrupted() 

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1dyjeeqz5j218y0ek76i.jpg)

注意：

> 如果目标线程在调用Object class的wait()、 wait(long)或wait(long, int)方法、 join()、
>
> join(long, int)、join(long, int)、 sleep(long, int)或sleep(long,int)方法时被阻塞。
>
> 此时线程被调用interrupt方法后， 该线程的中断状态将被清除，抛出InterruptedException
>
> 异常

代码演示

```Java
public class ThreadInterruptedDemo {
    @Test
    public void test01() throws Exception {
        Thread one = new Thread(() -> {
            System.out.println("新开始了一个线程");
            try {
                Thread.sleep(1000L * 10);
            } catch (InterruptedException e) {
                System.err.println("程序出现异常！");
                e.printStackTrace();
            }
            System.out.println("执行完成");
        });
        one.start();

        Thread.sleep(1000L * 1);
        try {
            one.interrupt();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
    }
}
```

当运行中调用了`interrupt()`方法，此时Thread执行异常处理的内容

结果如下

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e2ynz7mhj21p80d4diw.jpg)



