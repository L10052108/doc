## 创建一个线程



thread类

runable接口

future





## 防止线程结束的几种方法

- **线程sleep**

两种方法
```Java
@Test
public void test07() throws InterruptedException {
    new Thread(
            () -> {
                try {
                    System.out.println("----------start");
                    System.out.println();
                    Thread.sleep(1000L * 10);
                    System.out.println("----------end");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
    ).start();

   // Thread.sleep(1000L * 20);  // 方法一
    TimeUnit.SECONDS.sleep(20);  // 方法二
}
```

**线程join**

```Java
@Test
public void test27() throws InterruptedException {
    new Thread(
            () -> {
                try {
                    System.out.println("----------start");
                    System.out.println();
                    Thread.sleep(1000L * 10);
                    System.out.println("----------end");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
    ).start();

   Thread.currentThread().join();
}
```

**CountDownLatch**

```
@Test
public void test37() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);
    new Thread(
            () -> {
                try {
                    System.out.println("----------start");
                    System.out.println();
                    Thread.sleep(1000L * 10);
                    System.out.println("----------end");
                    latch.countDown();     // 如果不执行countDown方法，线程会一直阻塞
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
    ).start();

    latch.await();
}
```