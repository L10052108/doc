资料来源:<br/>
[CountDownLatch：别浪，等人齐再团](https://www.toutiao.com/article/6945655940335059489/?log_from=1fe6a9abeacb5_1650432031427) <br/>
[CyclicBarrier：人齐了，老司机就可以发车了](https://www.toutiao.com/article/6948963911949484556/?log_from=ba48146da0694_1650432109441) <br/>
[Semaphore自白：限流器用我就对了](https://www.toutiao.com/article/6953417246953800200/?log_from=0e26b35710b8d_1650432147091) <br/>

## 多线程分析工具VisualVM

window版本JDK中自带的工具，而mac版本需要安装

下载地址：https://visualvm.github.io/index.html

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1o1h3g6ldj219q0u0q7v.jpg ':size=60%')

下载完成以后，需要进行配置安装

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1o1kh28odj20n40fi3zp.jpg ':size=60%')

配置文件jd路径

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1o1kwzitzj20n408475h.jpg ':size=60%')



## countDownLatch

### 实现原理

CountDownLatch 中 count down 是倒数的意思，latch 则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有点“321，芝麻开门”的感觉，CountDownLatch 的作用也正是如此。

**CountDownLatch 在创建的时候需要传入一个整数，在这个整数“倒数”到 0 之前，主线程需要一直挂起等待，直到其他的线程都执行之后，主线才能继续执行。**

**执行流程**

CountDownLatch 的实现是在其内部创建并维护了一个 volatile 类型的整数计数器，当调用 countDown() 方法时，会尝试将整数计数器 -1，当调用 wait() 方法时，当前线程就会判断整数计数器是否为 0，如果为 0，则继续往下执行，如果不为 0，则使当前线程进入等待状态，直到某个线程将计数器设置为 0，才会唤醒在 await() 方法中等待的线程继续执行。

CountDownLatch是基于AQS的阻塞工具，阻塞一个或者多个线程，直到所有的线程都执行完成。

**常用的方法**

~~~~java
// 线程被挂起直到 count 值为 0 才继续执行
public void await() throws InterruptedException { };   

// 和 await() 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  

// 将 count 值减 1
public void countDown() { }; 
~~~~

**使用案例**

```java
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.RandomUtil;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CountLatchDemo {

    public static void main(String[] args) throws InterruptedException {
        TimeUnit.SECONDS.sleep(20);

        // 创建一个线程池，用来执行线程
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        // 只能5个线程同时执行
        CountDownLatch latch = new CountDownLatch(5);

        // 创建5个线程
        for (int i = 0; i < 5; i++) {
            final int NO = i;
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    try {
                        System.out.println("Accessing: " + NO);

                        Long r2 = (long) RandomUtil.randomInt(3000, 8000);
                        Thread.sleep(r2);
                        System.out.println("Finish: " + NO);
                        latch.countDown();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            };
            Long r1 = (long) RandomUtil.randomInt(0, 3000);
            Thread.sleep(r1);   // 随机休眠0-3秒
            threadPool.execute(runnable);  // 随机0-3秒，每个线程的开始执行的时间不同。
        }

        latch.await();
        System.out.println("所有线程都执行完成！" + DateUtil.now());
        Thread.sleep(1000L * 10);
        System.out.println("休眠结束：" + DateUtil.now());
        threadPool.shutdown();
    }
}
```

执行的结果：

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1o3qbyd74j217a0jadhr.jpg ':size=50%') 

线程的时序图

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1o44cach8j213y0gbjvo.jpg ':size=80%')

ountdownLatch：常被称作`门栓`, 用来进行线程的同步协作，等待所有线程到达后，在执行后续操作。

通过构造方法指定线程数量，

> 主线程使用`await()`进行等待线程到达
>
> 工作线程使用`countDown()`进行报到，也就是让计数减一。



## CyclicBarrier

...
## Semaphore
...
