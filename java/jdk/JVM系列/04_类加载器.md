资料来源：<br/>
[JVM系列-4.类加载器](https://juejin.cn/post/7326759323064041507)<br/>

# 类加载器

类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。 类加载器只参与加载过程中的字节码获取并加载到内存这一部分。

![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2089f4a58842419b4af3a3e9cc667c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1050&h=376&s=244130&e=png&b=fcfafa)

![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9bb13d5b3244bafbabacd00595ac032~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1006&h=369&s=219458&e=png&b=fcfbfb)

![3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595c37dda65b43e4a09e5f6a839b3bfe~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1105&h=529&s=95313&e=png&b=ffffff)

## 类加载器的分类

类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。

![4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b00bcfebd9e46f3b9608879a4128eaf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&h=421&s=106278&e=png&b=ffffff)

类加载器的设计JDK8和8之后的版本差别较大，**JDK8及之前的版本中默认的类加载器有如下几种：**

![5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05e36806500e4a34880b185e70605fc7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1102&h=451&s=67886&e=png&b=fdfbfb)

### Arthas中类加载器相关的功能

类加载器的详细信息可以通过classloader命令查看：

classloader - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource

![6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a5b63cc4014237b2cf2f84fc291db3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=903&h=358&s=81384&e=png&b=282c34)

### 启动类加载器

![7.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ea4827f5374586ab7259dfd85ec41d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1101&h=493&s=185767&e=png&b=dce3eb)

其中最核心的就是rt.jar是jdk8中最核心的jar包，平时用到的字符串String类，装箱类型Integer，还有日期类Date等等。启动类加载器将这些都加载进来之后，相当于提供了一个基础的运行环境。

```java
java复制代码ClassLoader classLoader = String.class.getClassLoader();
System.out.println(classLoader);

输出为null
```

但是由于这个类加载器不存在于java代码中，而是位于虚拟机环境中，所以在java环境中获取不到。所以出于安全性的考虑，在代码中，不允许我们获取到虚拟机的启动类。

制作jar的方式，idea maven install

### Java中的默认类加载器

扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。

**它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。**

![8.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35fd7e08cff45f8a02ad834ac0e7fb1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=273&s=111107&e=png&b=fbf8f8)

### 扩展类加载器

![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04c4add90c0c4abaa8c4f4acc10b0c4b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1050&h=463&s=159837&e=png&b=dce3eb)

### 应用程序类加载器

![10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6c06b1a83340c09f0469c9666d9bf6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1096&h=457&s=151685&e=png&b=fdfbfb)

### Arthas中类加载器相关的功能

类加载器的加载路径可以通过classloader –c hash值 查看：

![11.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86653adf2c164fedb9d99845473c32bb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=802&h=313&s=203327&e=png&b=282d34)

## 双亲委派机制

由于java虚拟机中有多个类加载器，双亲委派机制的核心就是解决一个类到底是由谁加载的问题。

![12.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a954e885d1ac460e98162b5b82e03eae~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=607&h=384&s=64230&e=png&b=fbf7f7)

![13.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25eb87fea4e1433b9529f6b82a15aa88~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1009&h=496&s=278414&e=png&b=fdfafa)

在Java中如何使用代码的方式去主动加载一个类呢？

方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。

方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。

在Idea中测试下面的案例：

![14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75444f9a4484eb58c29a42fcc50d863~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=817&h=298&s=117985&e=png&b=fdf9f9)

应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空。

启动类加载器使用C++编写，没有上级类加载器。

![15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad7ef34ff27d45259cfd3b68d9aaa76c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=543&h=366&s=32207&e=png&b=fcf8f8)

类加载器的继承关系可以通过classloader –t 查看：

![16.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64206ee8bc4842e29d0bbe7220655668~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=810&h=157&s=92449&e=png&b=282d34)

**如果类加载的parent为null，则会提交给启动类加载器处理。**

![17.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/471179205cc048ac812651bf5ede3d94~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=915&h=373&s=76331&e=png&b=fdfbfb)

如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。

![18.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4474546595884600a641376f088ac36a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=960&h=360&s=66135&e=png&b=fdfbfb)

第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。

![19.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f515ce9c40645b7bfa3e5e42b4e3506~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=919&h=333&s=63909&e=png&b=fdfafa)

双亲委派机制指的是：**自底向上查找是否加载过，再由顶向下进行加载。**

![20.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44e4adf56f843d4a81d72cdca046a53~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=657&h=358&s=48093&e=png&b=fcf8f8)

另一个案例：com.itheima.my.C这个类在当前程序的classpath中，看看是如何加载的。

![21.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186a9e2841144c8c8ef606192805ab95~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=702&h=367&s=59399&e=png&b=fbf8f8)

![22.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81a899a5453740c0b1251b2465b538d2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=765&h=369&s=104326&e=png&b=fcf9f9)

![23.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/709415a1fb4f4818b8cf14bce9d827d1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=582&h=499&s=119808&e=png&b=fdfcfc)

![24.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a3b9119035459e90434e70a005e8d6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=919&h=357&s=114941&e=png&b=fcfafa)

## 打破双亲委派机制

![25.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24fb8326929742e9b846da576b0d2baa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1009&h=394&s=107770&e=png&b=fffefe)

### 打破双亲委派机制–自定义类加载器

一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。

如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。

![26.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d2cfdb8861400097a96c63ae54799d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=549&h=319&s=42761&e=png&b=f7f4ee)

Tomcat使用了自定义类加载器来实现应用之间类的隔离。

每一个应用会有一个独立的类加载器加载对应的类。

![27.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae32fc0175040e6af48963a6baeb961~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=667&h=363&s=42937&e=png&b=f9f5f2)

先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法。

双亲委派机制的核心代码就位于loadClass方法中。

![28.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf9c291cbb1f472ba6fbae68bfceec60~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=946&h=385&s=128741&e=png&b=fff8f3)

阅读双亲委派机制的核心代码，分析如何通过自定义的类加载器打破双亲委派机制。

打破双亲委派机制的核心就是将下边这一段代码重新实现。

```java
java复制代码//parent等于null说明父类加载器是启动类加载器，直接调用findBootstrapClassOrNull
//否则调用父类加载器的加载方法
if (parent != null) {
 	c = parent.loadClass(name, false);
 	} else {
 		c = findBootstrapClassOrNull(name);
 	}
//父类加载器爱莫能助，我来加载！
if (c == null) 
 	c = findClass(name);
```

自定义类加载器父类怎么是AppClassLoader呢？

![29.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0c480179fa436faadb037507b52aad~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=603&h=370&s=46158&e=png&b=fbf7f6)

以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：

![30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86e3eec6e9e4444589355a33e6e6ed10~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=502&h=157&s=42850&e=png&b=fefdfd)

这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。

![31.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bf07b77ee2c4b62aa11e96ae0a2585a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=564&h=97&s=19886&e=png&b=fffefe)

两个自定义类加载器加载相同限定名的类，不会冲突吗？

**不会冲突**，在同一个Java虚拟机中，只有**相同类加载器+相同的类限定名**才 会被认为是同一个类。

在Arthas中使用sc –d 类名的方式查看具体的情况。

![32.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ffac7503a0453ea8f027a7473f4ce3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1869&h=1219&s=713846&e=png&b=272d37)

正确的去实现一个自定义类加载器的方式是重写findClass方法，这样不会破坏双亲委派机制。

![33.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8660cae09b8b48f9b30c351aaa8f1694~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=945&h=346&s=76988&e=png&b=fff8f3)

### 打破双亲委派机制的第二种方法：JDBC案例

JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。

![34.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb087573eec422d92483a4605d23d85~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=963&h=355&s=98191&e=png&b=fef9f8)

DriverManager类位于rt.jar包中，由启动类加载器加载。

![35.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0849aba5ca4e1581c1a466b5425adf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=604&h=373&s=84561&e=png&b=fdf7f3)

依赖中的mysql驱动对应的类，由应用程序类加载器来加载。

![36.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de1eeaf023ac4eb58a8af3902cc90990~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=816&h=349&s=52826&e=png&b=fef9f7)

DriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。

![37.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ae4030de014481a04f6cf842bd00b9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=562&h=309&s=51519&e=png&b=fdfbfb)

DriverManager怎么知道jar包中要加载的驱动在哪儿？

![38.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc9d8928a484d5fb85f5015cafea163~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=945&h=465&s=90745&e=png&b=ffffff)

DriverManage使用SPI机制，最终加载jar包中对应的驱动类。

![39.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad36d88e1c5c4e76bc5d4377ad84cb5a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=910&h=310&s=56988&e=png&b=fefdfd)

SPI全称为(Service Provider Interface) 是JDK内置的一种服务提供发现机制

其工作原理：

1.在ClassPath路径下的META-INF/services文件夹下，以接口的全限定名来命名文件名，对应的文件里面写该接口的实现。

2.使用ServiceLoader加载实现类

![41.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1ce5d8a1a8b414e8ab17c0c52eed530~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=994&h=214&s=74326&e=png&b=fcf9f9)

SPI中是如何获取到应用程序类加载器的？

SPI中使用了线程上下文中保存的类加载器进行类的加载，这个类加载器一般是应用程序类加载器。

![40.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/292eaafeebb04aec857a29e8fa0d3129~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=822&h=160&s=46881&e=png&b=fffdfd)

1、启动类加载器加载DriverManager。

2、在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动。

3、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。

**这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。**

![42.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89aac1d1cf3d475787248665b0d83021~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=898&h=292&s=62671&e=png&b=fefdfd)

### 打破双亲委派机制的第三种方法： OSGi模块化

历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了**热部署**的功能。

热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。

![43.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e22825143a14bb3a507c45aed39d109~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=505&h=321&s=37723&e=png&b=fefdfd)

#### 使用阿里arthas不停机解决线上问题

小李的团队将代码上线之后，发现存在一个小bug，但是用户急着使用，如果重 新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问 题修复。

**思路：**

- 在出问题的服务器上部署一个 arthas，并启动。
- jad --source-only 类全限定名 > 目录/文件名.java jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码
- sc -d 输入类名，找到hashcode
- mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录 mc 命令用来编译修改过的代码
- retransform class文件所在目录/xxx.class 用 retransform 命令加载新的字节码

**注意事项：**

1、程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。 2、使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。

## JDK9之后的类加载器

JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。

![44.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54b05559a85743028820fd2dc1ed8325~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=955&h=414&s=101553&e=png&b=fdfbfb)

由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。

![45.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce1a3d7a6a934676bf81e57fdb997f8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=450&h=355&s=144361&e=png&b=faf9f9)

启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。

Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。

**启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。**

![46.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2f67e8844694b6da4429d6ad782b066~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=756&h=202&s=46976&e=png&b=fefefe)

扩展类加载器被替换成了平台类加载器（Platform Class Loader）。

平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。**平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。**



作者：爱吃芝士的土豆倪
链接：https://juejin.cn/post/7326759323064041507
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。